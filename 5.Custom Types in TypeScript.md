## How can we use custom types in typescript 

let's start by declaring a function like draw point 

```js
let draw = (x, y) => {
    //...
}
```
* so this function takes an x and y and simply draws it on the screen
* now this function is not too bad, here we have only two parameters x and y

> but sometimes when working with more complex concepts we may end up with a function that

---

## The Problem: Too Many Parameters

```ts
let draw = (x, y, a, b, c, d) => {
    //...
}
```

* Passing many parameters makes functions **hard to read & maintain**.
* Often, these parameters belong to a **single concept** (e.g., a point, a car).

---

## Grouping Parameters into an Object

Instead of passing multiple values:

```ts
let draw = (x, y) => { /* ... */ }
```

We pass a single **object**:

```ts
let draw = (point) => {
    //...
}

draw({ x: 1, y: 2 }); // then we can call this function
```

> Cleaner function signature `however` there is a problem with this implementation.

---

## The Issue

We could accidentally pass the **wrong object**:

```ts

let draw = (point) => {
    //...
}

draw({ name: "Omar" }); // ❌ Runtime error
```

* JavaScript won’t stop us.
* TypeScript **catches errors at compile time**.

> so there are two solutions to solve this problem 

---

## Solution 1: Inline Annotation

```ts
let draw = (point: { x: number, y: number }) => {
    console.log(point.x + " " + point.y);
};

draw({ x: 1, y: 2 });
```

> Inline annotation it works fine for simple cases, but becomes **verbose** if reused or repeat this object in multiple places.

---

## Solution 2: Interfaces

Define a reusable **shape** of an object:

```ts
interface Point {
    x: number;
    y: number;
}

let draw = (point: Point) => {
    console.log(point.x + " " + point.y);
};

draw({ x: 1, y: 2 });
```

* Cleaner and reusable.
* But function (`draw`) is **separate** from the `Point` structure → violates cohesion.

---

## Cohesion Principle

**Cohesion** = related data + behavior should be grouped together.

Problem:

```ts
interface Point {
    x: number;
    y: number;
}

let draw = (point: Point) => { /* ... */ };
let getDistance = (pointA: Point, pointB: Point) => { /* ... */ };
```

* `draw` and `getDistance` are **floating around**.
* They belong with `Point`.

---

## Limitations of Interfaces in This Case

Interfaces:

* ✔️ Define a **contract** (properties + method signatures).
* ❌ Cannot include implementations of methods.

> That’s why we use a class here, since we want both data + behavior together.

---

## Solution 3: Classes

A **class** groups related data (properties) and behavior (methods):

```ts

class Point {

    x: number;
    y: number;

    draw() {
        console.log("Drawing point at (" + this.x + ", " + this.y + ")");
    }

    getDistance(another: Point) : number {
        const dx = this.x - another.x;
        const dy = this.y - another.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```
> Now everything related to a **Point** is in **one unit**.

---

## Benefits of Classes

* Encapsulate **data + behavior**.
* Apply **reusability** and **maintainability**.
* Follow **object-oriented principles**.

---

## Summary

* Avoid passing many related parameters separately → group them into an object.
* Use **interfaces** to define object shapes.
* use **classes** to keep data + related functions together.

---


