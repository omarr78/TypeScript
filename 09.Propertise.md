
## 1. The Problem

* We can **set** the initial coordinates of a `Point` and call `draw()`.
* But there’s **no way to read** the coordinates directly because fields are `private`.

Example:

```ts
let point = new Point(1, 2);
point.draw();
// Cannot access point.x directly → it's private
```

---

## Solution 1 – Getter Method

We can expose the value through a **getter method**:

```ts
getX() {
    return this.x;
}

let x = point.getX(); // works
```

> But this looks like a **method call**, not a simple field access.

---

## Solution 2 – Setter Method

Sometimes we want to **validate values** before changing them.

```ts
setX(value: number) {
    if (value < 0)
        throw new Error("Value cannot be less than 0.");
    this.x = value;
}

point.setX(10); // valid
```

> Still, it feels like a method rather than a property.

---

## 4. Properties (Getters & Setters)

TypeScript (like many OOP languages) provides **properties** for cleaner syntax.

```ts
class Point {
    constructor(private _x?: number, private _y?: number) {}

    draw() {
        console.log(`Drawing point at (${this._x}, ${this._y})`);
    }

    get x() {
        return this._x;
    }

    set x(value: number) {
        if (value < 0)
            throw new Error("Value cannot be less than 0.");
        this._x = value;
    }
}
```

---

## 5. Using Properties

From the **outside**, properties look like fields:

```ts
let point = new Point(1, 2);

console.log(point.x); // getter → 1
point.x = 10;         // setter → validates before updating
point.draw();         // Drawing point at (10, 2)
```

No need to call `getX()` or `setX()` — it’s **cleaner syntax**.

---

## 6. Naming Convention

* Fields → **camelCase** (e.g., `x`, `y`).
* To avoid clashes with property names, prefix private fields with `_`.

### Example: `_x` (field) and `x` (property).

---






