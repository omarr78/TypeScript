## Static Typing vs JavaScript

```ts
let count = 5;
count = 'a'; // ❌ Error
```

* **JavaScript**: variables can change type at runtime.
* **TypeScript**: prevents assigning a string to a number. `Compilation error`

```
Type 'string' is not assignable to type 'number'

```

---

## Compilation Behavior

* Even with errors, TypeScript still generates **valid JavaScript**.

```bash
tsc main.ts
node main.js
```

* Code runs, but may break at runtime.
* Example: using `count` in a loop could cause issues if it was accidentally set to a string.

> TypeScript helps us **catch such mistakes at compile time**.

---

## Type Inference

```ts
let count = 5; 
```

* Compiler **infers** that `count` is of type `number`.
* Hovering in VS Code shows:

```
let count: number
```

---

## The `any` Type

```ts
let a;    // inferred as 'any'
a = 1;
a = true;
a = "hello";
```

* `any` works like JavaScript variables → can hold **any type**.
* Not recommended (loses type safety).

---

## Type Annotations

If the value is unknown at declaration:

```ts
let a: number;
a = 1;
a = true; // ❌ Error
```

* Adding `: type` explicitly tells TypeScript the variable type.
* Helps catch errors early.

---

## Built-in Types in TypeScript

1. **number** → integers & floating-point

   ```ts
   let a: number;
   ```

2. **boolean** → true/false

   ```ts
   let b: boolean;
   ```

3. **string** → text

   ```ts
   let c: string;
   ```

4. **any** → dynamic (avoid when possible)

   ```ts
   let d: any;
   ```

5. **array**

   * Array of numbers:

     ```ts
     let e: number[];
     let f: number[] = [1, 2, 3];
     ```
   * Array of mixed values (not recommended):

     ```ts
     let g: any[] = [1, true, 'a', false];
     ```

---

## Enums

**Without Enums (JavaScript way):**

```js
const ColorRed = 0;
const ColorGreen = 1;
const ColorBlue = 2;
```

**With Enums (TypeScript):**

```ts
enum Color { Red = 0, Green = 1, Blue = 2 }

let backgroundColor = Color.Red;
```

### Benefits

* Groups related constants.
* IntelliSense support (`Color.` → auto-suggestions).
* Values auto-increment (but best practice: **set values explicitly**).

---

## Enums Compilation

```ts
enum Color { Red = 0, Green = 1, Blue = 2 }
```

Compiles to JavaScript:

```js
var Color;
(function (Color) {
    Color[Color["Red"] = 0] = "Red";
    Color[Color["Green"] = 1] = "Green";
    Color[Color["Blue"] = 2] = "Blue";
})(Color || (Color = {}));
```

> TypeScript makes it **cleaner and easier** to write.

---

## Type Assertions

Sometimes TypeScript may be a little bit confused about the type of a variable.

```ts
let message; // 'any'
message = 'abc';
let endsWithC = message.endsWith('c'); // 'any'
```



### Solution: Tell TS that `message` is a string

1. **Angle Brackets**

```ts
let endsWithC = (<string>message).endsWith('c');
```

2. **`as` Keyword**

```ts
let alternativeWay = (message as string).endsWith('c');
```

* Both are the same.
* Only affect the **compiler**, not runtime.
* Gives IntelliSense and better type checking.
* which one to use - it depends on your personal preference but the first approach is what you see more in a lot of tutorials

---

## Summary

* TypeScript adds **static typing** → fewer runtime errors.
* Use **type annotations** when inference isn’t enough.
* Avoid **`any`** whenever possible.
* Use **`let`/`const`** instead of `var`.
* Enums & Type Assertions make code **cleaner** and **safer**.

---

